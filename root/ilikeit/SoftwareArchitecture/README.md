Software Architecture
=====================

```
架构设计的关键思维是判断和取舍
程序设计的关键思维是逻辑和实现
```

* 架构基础
```
模块 vs. 组件
    模块(Module): 是一套一致而互相有紧密关联的软件组织
    组件(component): 自包含、可编程、可重用、与语言无关的软件单元

    模块和组件是系统的组成部分，只是从不同的角度拆分系统
        - 逻辑角度拆分得到的单元就是“模块”
            + 划分模块的目的是职责分离
        - 物理角度拆分得到的单元就是“组件”
            + 划分组件的目的是单元复用

框架 vs. 架构 
    软件框架(Software framework): 通常指为实现软件组件规范时，提供规范所要求基础功能的软件产品
    软件架构(Software Arichiture):软件架构指软件系统的顶层结构

1940年之前: 机器语言 
20世纪40年代: 汇编语言 
20世纪50年代: 高级语言 
20世纪60年代～20世纪70年代: 软件危机与结构化程序设计
    结构化程序本质上是一种面向过程的设计思想，但通过"自顶向下、逐步细化、模块化"的方法，将软件的负责度控制在一定范围内
20世纪80年代: 第二次软件危机与面向对象
20世纪90年代: 
    卡内基梅隆大学的玛丽肖(Mary Shaw)和戴维加兰(David Garlan) 1994那年《An Introduction to Software Architecture》
        “When systems are constructed from many components, the organization of the overall system-the software architecture-presents a new set of design problems.”

架构设计的真正目的:
    架构设计的主要目的是为了解决复杂度带来的问题原则

高性能:
    电子管计算机->晶体管计算机->集成电路计算机
    硬盘存储:纸带->磁带->磁盘->SSD
    软件系统中高性能带来的复杂度主要体现在两方面:
        1. 单机计算机内部为高性能带来的复杂度 
            计算机内部复杂度最关键的地方就是操作系统
            操作系统和性能最相关的就是进程和线程
                进程要求独立内存空间，进程间不干扰
                    进程间通信：管道、消息队列、信号量、共享存储
                线程是进程内部的子任务，线程共享进程内存，保证数据的正确性，需要互斥锁机制
            线程是操作系统调度的最小单位、进程是操作系统分配资源的最小单位
            多CPU同时执行任务:
                SMP (Symmetric Multi-processor): 对称多处理器结构 -- 目前比较流行
                NUMA (Non-Uniform Memory Access): 非一致存储访问结构 
                MPP (Massive Parallel Processing): 海量并行处理结构
        2. 多台计算机集群为高性能带来的复杂度 
            多机配合支持高性能复杂任务
            2.1 任务分配: (通过任务分配的方式、能够突破单机机器处理性能的瓶颈，通过增加更多的机器来满足业务的性能需求)
                单台任务分配:每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行
                    任务分配器:
                        硬件网络设备: 交换机
                        软件网络设备: LVS
                        负载均衡软件: Nginx, HAProxy 
                    任务分配器和业务服务器之间的连接和交互:
                        连接建立、连接检测、连接中断
                    分配算法:
                        轮询算法、权重分配、负载分配

                多台任务分配器:
                    将不同的用户分配到不同的任务分配器上:
                        DNS轮询、智能DNS、CDN(Content Delivery Network,内容分发网络)、GSLB(Global Server Load Balance, 全局负载均衡)设备
                    任务分配器和业务服务器连接从简单的“1对多”转变为"多对多"
            
            2.2 任务分解()
                任务分解能够把原来大一统但复杂的业务系统拆分成小而简单但需要多个系统配合的业务系统
                简单系统更容易做到高性能
                可以针对单个任务进行扩展
                任务分解越细,系统间调用次数会呈指数级别上升，而系统间的调用通道目前都是通过网络传输的方式、性能远比系统内的函数调用低的多 

高可用:
    > 系统无中断地执行功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一
    通过“冗余”实现高可用
        高性能增加机器目的在于“扩展”处理性能
        高可用增加机器目的在于"冗余"处理单元
        常用的多机算法: 
            主备: 冷备、温备、热备
            主主:
        计算高可用:
        存储高可用: 
            物理上传输速度限制、传输线路本身有可用性问题(传输线路可能中断、堵塞、异常)
            保证数据的一致性(数据+逻辑=业务)
            存储高可用的难点在不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响
        分布式领域著名CAP定理:从理论上论证存储高可用的复杂度，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，要求在做架构设计时结合业务进行取舍
        高可用状态决策:
            无论是计算高可用还是存储高可用，基础都是"状态决策"，系统需要能够判断当前状态是正常还是异常
            1. 独裁式决策: 存在一个独立的决策主体称为“决策者”，负责收集信息然后决策，所有的冗余个体称为“上报者”，都将状态信息发送给决策者
                独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，当决策者故障，整个系统就无法时下准确的状态决策，如果决策者本身又做了一套决策者，就陷入递归的死循环
            2. 协商式决策: 多个独立的个体通过交流信息，然后根据规则进行决策
                最常用的协商式决策就是主备决策
            3. 民主式决策: 多个独立的个体通过投票方式进行状态决策，
                ZooKeeper集群在选举leader就采用这种方式，选举算法Paxos 
                民主式决策有固有的缺陷:脑裂的原因式原来统一的集群因为连接中断，造成两个独立分隔的子集群，每个子集群独立进行选举，于是选出2个主机，相当于人体有两个大脑
                民主决策系统一般采用"投票节点数必须超过系统总结点数的一半"规则处理

可扩展性:
    > 系统为了应对将来需求变化而提供的一种扩展能力,
    设计具备良好可扩展性的系统:
        有两个基本条件:正确预测变化、完美封装变化
        1. 预测变化的复杂性:
            1.1: 不能每个设计点都考虑可扩展性
            1.2: 不能完全不考虑可扩展性
            1.2: 所有的预测都存在出错的可能性
        2. 应对变化:
            2.1: 将"变化"封装在一个“变化层”，将不变的部分封装在独立的"稳定层"
                例如：系统需要支持XML、JSON、ProtocolBuffer三种接入方式;系统需要支持MySQL、Oracle、DB2数据库存储
                装饰者模式:




    Nginx支持多进程、多线程
    JBoss采用的是多线程 
    Redis采用的单进程
    Memcache采用的多线程
    ZooKeeper采用一主多备
    Memcache采用全主0备
```

* 高性能架构模式
```
```

* 高可用架构模式
```
```

* 可扩展架构模式 
```
```

* 架构实战
```
```