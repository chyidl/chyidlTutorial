Software Architecture
=====================
```
物理服务器: [CPU 内存 磁盘 网卡]
  操作系统: [进程管理、硬件资源管理]
    JVM进程: [进程内虚拟机管理]
      TOMCAT容器: [每个用户请求分配一个线程，执行应用程序代码]
        应用程序: [可执行字节码war包]

多线程访问共享资源的代码被称为临界区,线程安全问题主要方法是使用锁，将临界区的代码加锁,只有获得锁才能执行临界区代码. 锁会引起线程阻塞,
被阻塞的线程越多，占据的系统资源越多，被阻塞线程不能继续执行，也不能释放当前占据的资源，在系统中一边等待一边消耗资源,如果阻塞的线程数超过某个系统资源的极限，会导致系统宕机，应用崩溃

解决系统因高并发而导致的响应变慢，应用崩溃主要手段是使用分布式系统架构。或在请求入口进行限流，减少系统的并发请求数
```

```
数组: 内存连续空间，存放相同的数据类型; 随机快速读写;
链表: 不连续存储，
Hash表: Key,Value 方式存储；Hash表的物理存储其实是数组, 根据Key计算出数组下标, Hashcode: 余数法; Hash冲突解决方法是链表法
栈: 后进先出 -- 在线性表基础上增加操作权限，因为栈不需要随机访问，也不需要在中间添加、删除数据可以使用数组实现或链表实现
队列: 先进先出 
  数组+链表+栈+队列称为线性表: 每个数据元素的前面只能有一个前驱数据元素，后面也只能有一个后继数据元素.
树: 非线性表
```

```
JVM: Java Virtual Machine 
  1. 类加载器
  2. 运行时数据区 [方法区 + 堆 + Java 栈 + 程序计数寄存器]
  3. 执行引擎 : 执行引擎执行字节码指令是解释执行,JVM进行优化，将频繁执行的代码编译为底层CPU指令存储起来(JIT) -server 参数打开JIT C2编译器进行优化

JVM 使用一种可达性分析算法：引用标记算法 
  JVM 对垃圾对象占内存进行回收三种方法:
    1. 清理: 垃圾对象占用的内存空间标记为空闲
    2. 压缩: 从堆空间的头部开始，将存活的对象拷贝放在一段连续的内存空间中，其余空间就是连续的空间空间
    3. 复制: 将堆空间分成两部分:其中一部分创建对象,当这个部分空间用完的时候，将标记的可用对象复制到另一个空间中,JVM 将两个空间分别命名为from区域和to区域

  JVM 具体进行垃圾回收时候，进行分代回收，JVM将堆空间分成新生代Young,老年代old两个区域,新生代分为Eden区，From区，To区三个区域:每次垃圾回收都是扫描Eden区和From区，将存活对象复制到To区，然后交换From区和To区的名称引用，下次垃圾回收的时候继续将存活对象从From 区复制到To区，当一个对象讲过几次新生代垃圾回收，也就是几次从From区复制到To区以后，依然存活，那么这个对象就会被复制到老年代区域.

当老年代空间满，将会堆新生代和老年代的内存空间进行一次全量垃圾回收，Full GC.

垃圾回收器:
  1. Serial串行垃圾回收器: 只有一个线程执行垃圾回收
  2. Parallel并行垃圾回收器: 启动多线程垃圾回收
  当垃圾回收线程工作的时候，必须要停止用户线程的工作 -- 垃圾回收称为"stop the world" 
  3. CMS 并发垃圾回收器: 垃圾回收的某些阶段，垃圾回收线程和用户线程可以并发运行 
  4. G1垃圾回收器: 将对空间分成多个子区域，然后在子区域上独立进行垃圾回收，

OutOfMemoryError: 堆空间不足 调整-Xmx参数增加内存空间 可以使用jmap命令查堆中对象情况分析是否存在内存泄漏
StackOverflowError: 栈帧太多，查看栈异常信息观察是否存在错误的递归调用 调整-Xss 参数增加栈空间
运行卡顿,部分请求响应延迟，可以通过jstat命令查看垃圾回收器 是否出现较长时间的FullGC 调整垃圾回收器相关参数

内存溢出 VS 内存泄漏
  内存溢出: 申请内存超过JVM当前可以分配的最大内存，溢出
  内存泄漏: 期望被回收的内存对象没有被回收，泄漏
```

```
分片策略:Sharding 分库分表 水平切片 垂直切片
数据备份: 数据备份 when, how
数据迁移: 分布发生拓扑变化，把数据从原来节点迁移到新节点
集群管理: 如何将用户请求定向到某个特定的节点上
```

```
网络编程原理:
  IP: Internel protocol: IP地址是互联网的地址标识
  DNS: 域名解析服务器 
  CDN: 内容分发网络 Content Delivery Network. 在运营服务商接入机房中部署缓存服务器，缓存静态图片，资源文件，这些缓存服务器构成淘宝的CDN 
  HTTP:应用层协议 (网络底层通信协议)
    - HTTP Status: 
      - 200 正常
      - 3xx 重定向 (302-请求被临时重定向到新的URL;响应头中包含新的临时URL,客户端收到响应后，重新请求新的URL)
      - 4xx 客户端错误 (403-请求未授权，404-请求页面不存在)
      - 5xx 服务器异常 (500-请求未完成，502-请求处理超时, 503服务器过载)
  TCP:传输层协议- 网络底层协议 以bit流方式

应用层 -> 传输层 -> 网络层 -> 数据链路层 -> 物理层
传输层协议TCP和网络层协议IP构成TCP/IP协议栈
  
物理层: 真实的通信线路光纤、电缆、无线各种设备，光信号和电信号，以及无线电磁信号
数据链路层: 将数据进行封装后交给物理层进行传输 数据链路层会定义帧的大小--最大传输单元
IP协议不是一个可靠的通信协议 并不会确保数据一定送达

TCP 三次握手:
  SYN=1 Seq=X ->   X: 随机数
  SYN=1 ACK=X+1 Seq=Y <- 
  ACK=Y+1 Seq=Z 
  三次报文建立一个TCP连接
  SYN: 请求建立连接 
  ACK: 表示确认

TCP头：包含校验数据正确性和控制数据流量的信息外，还包括通信端口信息

LB: 负载均衡服务器
  1. Linux内核支持的链路层负载均衡 - 直接路由模式:直接修改数据帧中的Mac地址
```

```
硬盘: 一种可持久保存，多次读写数据的存储介质
  1. 机械式硬盘: 读写数据需要移动磁头；相比离散存储的同样大小的文件，连续存储的文件的读写速度要快得多
  2. 固态硬盘: 
  固态硬盘和机械式硬盘混合部署的方式：日志文件系统存储在机械硬盘，系统文件和随机读写文件存储在固态硬盘上
  inode: 文件控制块 获取文件的inode信息，在inode中查找文件数据索引表，根据索引中记录的硬盘地址信息访问硬盘读写数据
  inode:中记录文件权限，所有者，修改时间，文件大小等文件属性信息
  inode是固定结构，能够记录的硬盘地址索引数也是固定的，只有15个索引,其中前12个索引直接记录数据块地址,第13索引记录索引地址: 每个inode最多可以存储12+256+256*256+256*256*256 * 4K = 67372080 

RAID: 磁盘冗余阵列:将多块硬盘通过硬件RAID卡或者软件RAID的方案管理起来. 利用文件系统将数据写入硬盘中不同数据块的特性,一个文件的多个数据块可能写入多个硬盘
  RAID 0 : 将文件数据分成N片，同时向N个硬盘写入文件容量扩大N倍，理论上读写速度扩大N倍 任何一块硬盘损坏 都会导致数据不完整 文件可用性极低 
  RAID 1 : 利用两块硬盘进行数据备份，文件同时向两块硬盘写入 -- 文件可用性得到提升
  RAID 10 : 是RAID 0，RAID1: 组合 扩大文件的容量，又提高文件的可用性，
  RAID 5: 
  RAID 6 

分布式文件系统:
  HDFS: 
    1. DataNode: 负责文件数据的存储和读写操作
    2. NameNode: 负责分布式文件系统的元数据MetaData管理,
  MapReduce & Spark
```

```
数据库架构:
  RDBMS: SQL -> 连接器 -> 语法分析器 -> 语义分析与优化器 -> 执行引擎
    连接器: 存储空间用于会话上下文管理
    语法分析器: 生成抽象语法树
    语义分析与优化器：将复杂嵌套的SQL进行语义等价转化
    执行计划: explain 
Statement 
PrepareStatement 预编译SQL; 避免SQL注入攻击,数据库语言生成好执行计划，不可能在再生成新的SQL
数据库索引使用B+树(N叉排序树) B+数加快索引的检索速度
数据库索引有两种:
  1. 聚簇索引 -- 聚簇索引的数据库记录和索引存储在一起 
    MySQL 主键ID和所在的记录行存储在一起 
  2. 非聚簇索引 -- 在叶子节点记录是聚簇索引 就是主键 -- 回表查询

事务日志文件: 进行事务操作时，事务日志文件会记录更新前的数据记录，然后再更新数据库中的记录
binlog 日志文件:记录全部的数据更新操作记录
```

```
莱布尼兹 -- 微积分 + 二进制 
辩证唯物主义，事物发展轨迹是波浪前进，螺旋式上升，有的时候似乎重新回到过去，但是却有本质的区别和进步

Java Web程序运行时环境:
  JVM 虚拟机进程
  主线程
  创建一些其它线程[负责监听80端口的线程，处理客户端连接请求的线程，执行用户请求的线程]
```

```
持久化: 持久化层在业务逻辑层和数据库层起到衔接的作用. 可以将内存中的数据模型转换为存储模型，或者将存储模型转换为内存中的数据模型
ORM抽象了数据的存取，同时兼容多种DBMS
SQLALchemy 支持ORM和支持原生SQL两种方式 
OLTP: 联机事务处理: -- 方便对数据记录进行增删改查，适合采用行式存储
OLAP: 联机分析处理:

COUNT(*) COUNT(1): 执行复杂度都是O(N), 采用全表扫描，进行循环+计数的方式进行统计 / InnoDB 采用行级锁和MVCC机制
MyISAM存储引擎：统计数据表的行数只需要O(1)的复杂度,而一致性由表级锁

COUNT(*) 和COUNT(1) 统计数据行数，尽量采用二级索引，因为主键采用的索引是聚簇索引
SQL 中可以在WHERE子句和ORDER BY子句中使用索引，目的是在Where子句中避免全表扫描
_ 匹配任意一个字符，%匹配大于等于0个任意字符
一条完整的SELECT语句内部的执行顺序是:
  1. FROM 子句组装数据 (包括通过ON 进行连接)
  2. WHERE子句进行条件筛选
  3. GROUP BY 分组
  4. 使用聚集函数进行计算
  5. HAVING筛选分组
  6. 计算所有表达式 
  7. SELECT字段 
  8. ORDER BY 排序 
  9. LIMIT筛选

数据库调优: -- 响应时间更快，吞吐量更大
表结构遵循第三范式原则:
  反范式采用空间换时间的方式，增加冗余字段提高查询的效率
SQL查询优化，分为逻辑查询优化和物理查询优化
  1. 如果数据重复度高，就不需要创建索引 
  
数据表的设计范式-关系型数据库:
  超键: 能唯一标识元祖的属性集叫做超键 
  候选键: 超键不包括多余的属性，这个超键就是候选键
  主键: 用户可以从候选键中选择一个作为主键 
  外键: 
  主属性: 任一个候选键的属性称为主属性 
  非主属性: 与主属性相对，指的是不包含任意一个候选键中的属性
  1. 1NF 第一范式: 数据表中的任何属性都是原子性 不可再分
  2. 2NF 第二范式: 保证表中的非主属性与候选键完全依赖
  3. 3NF 第三范式: 保证表中的非主属性与候选键不存在传递依赖
  4. 4NF 第四范式: 
  5. 5NF 第五范式 
  数据库的范式设计越高阶，冗余度越低 
  范式等级越高，设计出来的数据表就越多，进行数据查询的时候就可能需要关联多张表，从而影响查询效率,
  允许少量的冗余，通过空间来换取时间

当冗余信息有价值活着能大幅度提高查询效率的时候，就可以采取反范式的优化
数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计
索引就是帮助数据库管理系统高效获取数据的数据结构
  
索引的种类:
  1. 普通索引: 没有任何约束，主要用于提高查询效率
  2. 唯一索引: 在普通索引的基础上增加数据的唯一性的约束
  3. 主键索引: 主键索引在唯一索引的基础上增加不为空的约束
  4. 全文索引 

聚集索引：的叶子节点存储就是数据记录, 
非聚集索引: 叶子节点存储的是数据位置
单一索引: 索引列为一列 
联合索引: 索引为多列
最左匹配原则: 
索引会占用存储空间，降低数据库的写操作的性能
数据量大的时候不实用索引是不可想像，必将索引的本质，是帮助我们提升数据检索的效率

B+ 树作为索引的数据结构
索引的数据结构尽量减少硬盘的I/O操作 
二分查找法是一种高效的数据检索方式，时间复杂度为O(log2n) -- 
Binary Search Tree: 二叉搜索数
AVL 数: 平衡二叉树-每个节点的左子树和右子树的高度差不能超过1 
当数据量N大的时候，以及树的分叉树M大的时候，M叉树的高度会远小于二叉树的高度
B Tree: Balance Tree 平衡多路搜索树
B+ Tree Vs B Tree: 
  B Tree: 孩子数量=关键字数量+1 
  B+ Tree:孩子数量=关键字数
  非叶子节点的关键字也会同时存在子节点中，并且是子节点中所有关键字的最大(或最小)
  非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中，而B树中，非叶子节点既保存索引，也保存数据记录 
  B+树的中间节点不直接存储数据，B+树查询效率稳定
  B+树的查询效率更高，同样的磁盘页大小，B+树可以存储更多的节点关键字

Hash索引
  Hash - 散列函数 
 
键值Key通过Hash映射找到Bucket，Bucket指的是一个能存储一条或多条记录的存储单位

Hash索引 Vs B+ 树索引:
  Hash索引(无序)不能进行范围查询; B+树(有序链表)可以 
  Hash索引不支持联合索引的最左侧原则，
  Hash索引不支持Order BY 排序
  Hash索引效率对于等值查询效率比较高 但是不会用于重复值多的列上，比如列为性别，年龄的情况

Redis 键值型Key-Value 数据库中Redis存储的核心就是Hash表
DISTINCT 对字段创建索引 - 索引会对数据按照某种顺序进行排序
连接表查询，没增加一张表就相当于增加一次嵌套的循环
频繁更新的字段不一定要创建索引，因为更新数据的时候，也需要更新索引 如果索引太多，在更新索引的时候会造成负担

索引失效：
  1.索引进行表达式计算 
  2.索引使用函数，会造成失效
  3.Where 子句中 or前的条件列进行索引，而在or后条件列没有进行索引，那么索引会失效
  4.使用LIKE进行模糊查询，首位不能是%
  5.索引列与NULL或者NOT NULL 进行判断的时候会失效
  6.联合索引的时候注意最左原则

数据库中的存储结构:
  1. 在数据库中，无论读一行，还是读多行，都是将这些行的页进行加载 Page
    Page: 一页中存储多行记录 Row  16KB  SHOW VARIABLES LIKE '%inodb_page_size%';
    数据页:
    系统页:
    Undo页:
    事务数据页:
  Extent: 区: 区在文件系统是一个连续分配的空间
  Segment: 段 
  Tablespace: 表空间: 划分为系统表空间，用户表空间，撤销表空间,临时表空间

  InnoDB 存在两种表空间类型：共享表空间、独立表空间[数据和索引信息都会保存在自己的表空间中]
  每张表都会独立保存为一个.ibd文件

  数据库I/O操作的最小单位是页: 
    文件头: File Header  -- 描述页的信息
    页头: Page Header -- 页的状态信息
    最大最小记录 Infimum + supremum  -- 
    用户记录: User Records -- 存储行记录内容
    空闲空间: Free Space -- 
    页目录: Page Directory
    文件尾: File Tailer 

采用链表的结构让数据页之间不需要是物理上的连续，而是逻辑上的连续

数据库会采用缓冲池的方式提升页的查询效率
数据库缓冲池:
  对数据库中记录进行修改的时候，首先会修改缓冲池中页的记录信息然后数据库会以一定的频率刷新到磁盘上
  checkpoint: 脏页dirty page: 缓冲池中被修改过的页，与磁盘上的数据页不一致
  innodb_buffer_pool_size: 查询缓冲池的大小
  innodb_buffer_pool_instances: 查看缓冲池的个数

缓冲池三种读取数据的方式:
  1. 内存读取 
  2. 随机读取 
  3. 顺序读取 
SHOW STATUS LIEK 'last_query_cost': 变量值查看当前查询的成本
过滤因子的条件过滤能力越强，满足条件的记录数就越少

三星索引:
  1. 在Where条件语句中，找到所有等值谓语的条件列，将他们作为索引的开始列 
  2. 将GROUP BY 和 ORDER BY 中的列加入到索引中 
  3. 将SELECT字段中剩余的列加入到索引片中

首先一张表的索引个数不宜过多，否则一条记录的增加和修改，会因为过多的索引造成额外的负担 

锁: 悲观锁 VS 乐观锁 
  加锁保证数据的一致性
  锁粒度:
    行锁: -- InnoDB 
    页锁:
    表锁: -- InnoDB
  数据库管理角度对锁划分：
    共享锁: 读锁- 可以被其他用户读取不能修改 
      LOCK TABLE table_name READ; 
      UNLOCK TABLE;
      lock in share mode.
    排他锁:
      LOCK TABLE table_name WRITE; 
    意向锁:
  
  乐观锁: Optimistic Locking 认为对同一数据的并发操作不会总发生，属于小概率事件 
    乐观锁的版本号机制: 表中设计一个版本字段version,第一次读的时候，会获取version字段的取值，然后对数据更新或删除，会执行UPDATE SET version=version+1 where version=version 
    乐观锁的时间戳机制: 
    乐观锁就是程序员自己控制数据并发操作的权限，

  悲观锁: Pessimistic Locking 

  乐观锁适合读操作多的场景，相对来说写的操作比较少 
  悲观锁适合写操作多的场景，因为写操作具有排他性，
  
  乐观锁和悲观锁并不是锁，而是锁的设计思想

  避免死锁的情况:
    1. 事务中涉及多个表，操作比较复杂，可以尽量一次性锁定所有的资源，而不是逐步获取，这样可以减少死锁发生的概率 
    2. 如果事务需要更新数据表中的大部分数据，数据表又比较大，可以采用锁升级的方式，将行锁升级为表级锁，从而减少死锁产生的概率 

MVCC: Multiversion concurrency control: 多版本并发控制 
  1. 解决读写之间阻塞问题 
  2. 降低死锁的概率 
  3. 解决一致性读的问题 

  快照读 VS 当前读 
    不加锁的SELECT属于快照读: SELECT * FROM player WHERE 
    加锁的SELECT或者对数据进行增删改都会进行当前读 SELECT * FROM player LOCK IN SHARE MODE;

  InnoDB 中MVCC实现机制
    1.事务版本号 -- 自增长 
    2.行记录的隐藏列 -- 
      db_row_id: - 隐藏的行ID 生成默认聚集索引
      db_trx_id, - 数据的事务ID
      db_roll_ptr - 回滚指针
    3. Read View
      trx_ids: 系统当前正在活跃的事务ID集合 
      low_limit_id: 活跃的事务中最大的事务ID 
      up_limit_id: 活跃的事务中最小的事务ID 
      creator_trx_id: 创建Read View 的事务ID
  MVCC 中通过Undo Log + Read View 进行数据读取，Undo Log保存历史快照，Read View 规则帮我们判断当前版本数据是否可见 

  InnoDB中三种行锁:
    1. 记录锁：针对单个行记录增加锁 
    2. 间隙锁: Gap Locking 帮我们锁住一个范围 索引之间的空隙，不包含记录本身 
    3. Next-Key 锁 锁住一个范围，同时锁定记录本身，相当于间歇锁+记录锁，可以解决
    可重复读： InnoDB采用Next-Key锁机制，解决欢幻读的问题 
  Undo log + Read View: 
  Undo Log: 保存数据的历史版本 实现多版本的管理

事务和索引的使用是数据库中两个重要核心：
  1. 事务可以让数据库在增删改查过程中，保证数据的正确性和安全性 
  2. 索引可以帮助数据库提升数据的查找效率

查询优化器:
  SQL语句 -> 分析器[语法分析、语义检查] (语法分析树) -> 优化器[逻辑优化、物理优化] -> 执行器 -> 
  查询优化器两种优化方式:
    1. 规则优化器 RBO Rule-Based Optimizer 
    2. 代价优化器 CBO Cost-Based Optimizer 

  mysql.server_cost 
disk_temptable_create_cost : 临时表文件创建代价     
disk_temptable_row_cost : 临时表文件行代价 
key_compare_cost   : 键比较的代价 
memory_temptable_create_cost  : 内存中临时表的创建代价 
memory_temptable_row_cost   : 内存中临时表行代价 
row_evaluate_cost  : 统计符合条件的行代价 

  mysql.engine_cost 
io_block_read_cost: 磁盘中读取一页的代价
memory_block_read_cost: 内存中读取一页数据的代价

COST = PAGE FETCH + W * (RSI CALLS)
总代价 = I/O 代价 + CPU代价

性能分析工具:
  数据库调优?
    1. 观察 Show Status 
    2. 行动  Action 
    观察服务器状态 -> 判断是否周期性波动 增加缓存/开启慢查询(long_query_time) EXPLAIN SHOW PROFIle
    SQL查询是否是瓶颈 -> 读写分离(主从架构) 分库分表(垂直分库，垂直分表，水平分表)
  慢查询、EXPLAIN、SHOW PROFILING 
  show variables like '%slow_query_log'; set global slow_query_log="ON"; 
  show variables like '%long_query_time%'; A
  mysqldumpslow 工具统计慢查询日志

EXPLAIN: 执行计划
  all: 全数据表扫描
  index: 全索引表扫描
  range: 索引列进行范围查找 
  index_merge: 合并索引，使用多个单列索引搜索
  ref: 根据索引查找一个或多个值 
  eq_ref: 搜索使用primary key 或 unique 类型 
  const: 
  using index: 索引可以覆盖select中字段

SHOW PROFILE 查看SQL具体的执行成本  
  show variables like 'profiling';
  show profile cpu, block io for query 2;A

B+ 树可以使用范围查找，按照顺序方式对数据进行存储，进行排序操作 
Hash索引 仅能满足 = <> IN 查询 不能使用范围查询 
自适应Hash索引只保存热数据(经常被使用到的数据)并非全表数据
InnoDB 自适应Hash相当于 索引的索引，采用Hash索引存储的B+树索引中的页面的地址
Hash表是数组+链表的形式，通过Hash函数可以计算索引键值对应的Bucket桶的位置，如果产生Hash冲突，就需要遍历链表解决
show variables like '%adaptive_hash_index' 查看是否开启自适应Hash

联合索引的最左前缀匹配原则针对的是创建联合索引中的顺序 

查看是否使用查询缓存：
  show variables like '%query_cache%'; 
缓冲池并不等于查询缓存，共同点都是通过缓存机制来提升效率，但缓冲池服务于数据库整体的I/O操作

InnoDB Vs MyISAM :
  InnoDB 支持事务和行级别锁 
  MyISAM 支持表级锁 不支持事务 

Cookies:  存储数据总量大小4KB 
Local Storage: 持久化的本地存储
Session Storage: 只存在于Session会话中 
WebSQL IndexedDB 都是HTML5本地缓存技术 
WebSQL DB API: 是一种操作本地数据库的网页API接口 SQLite 实现本地存储
IndexedDB 存储的是key-value 类型的数据 支持事务 

微信采用SQLite作为本地聊天记录的存储
SQLite 不适用高并发，同一时间只允许一个写操作
SQLite 仅支持只读视图，只能创建和读取视图，不能对他们内容进行修改 
```

```
Redis key-value 数据库 键值数据库的查询性能高，易于扩展 
  Redis每秒最多请求达到10万次 
  Redis基于内存的数据库，避免磁盘I/O 缓存工具 
  Redis 采用单进程单线程模型，避免上下文切换和不必要的线程之间资源竞争 
  Redis采用多路I/O复用技术(多个socket网络连接,复用一个线程)

Redis 数据类型:
  1. 字符串类型： key-value 
  2. 哈希 hash: 字段和字段值的映射 key-filed-value 
  3. 字符串列表list: 双向链表 LPUSH RPUSH LRANGE 
  4. 字符串集合set: 无序 不重复 SADD SREM SMEMBERS SISMEMBER 
  5. 有序字符串集合 zset: score hash表结构 ZADD ZSCORE ZRANGE ZREVRANGE 
  6. bitmaps: 位图 
  7. HyperLogLog: 基数统计 
  8. Geospatial: 地理空间 
  9. Streams: 数据流

连接池机制可以避免频繁创建和释放连接，提升整体的性能 
连接池机制的原理:
  1. 连接池实例中会有两个list 
    available_connections: 可以使用的连接集合
    in_use_connections: 正在使用的连接集合

memcached 是多线程，可以利用多核优势
redis提供两种持久化模式，可以让数据永久保存 RDB, AOF 模式
  RDB redis Database: 持久化将当前进程的数据生成快照保存到磁盘上 触发RDB持久化的方式分为手动触发和自动触发，因为持久化操作与命令操作不是同步进行，所以无法保证事务的持久性
  AOF Append Only File: 持久化采用日志的形式记录每个写操作 
    everysec: 每秒同步一次 
    always: 只要数据发生修改就会写入AOF文件 
    no: 由操作系统决定什么时候记录到AOF文件中

Redis 事务处理:
  1. MULTI: 开启事务 
  2. EXEC: 事务执行，一次性执行事务内所有命令
  3. DISCARD: 取消事务 
  4. WATCH 监视一个或多个键，如果事务执行前某个键发生改动，事务就会被打断 
  5. UNWATCH: 取消WATCH命令对所有键的监视 

redis 事务处理机制:
  ACID: 原子性、一致性、隔离性、持久性
  Redis不支持事务的回滚机制Rollback 

使用Redis的WATCH 和 MULTI命令处理共享资源的并发操作
MULTI 后不能再执行WATCH命令，否则会返回WATCH inside MULTI is not allowed

WATCH + MULTI 乐观锁: 通过程序实现的锁机制，在数据更新的时候进行判断，成功就执行，不成功就失败，不需要等待其他事务来释放锁

redis 的 incr和decr实现键的原子性递增或递减 

MySQL擅长存储数据，对于数据的运算效率低，通常需要后端语言进行统计 
Redis提供丰富的排行榜统计功能，无论增加、删除玩家，对玩家进行调整，都可以对排行榜实时更新

MongoDB 面向文档数据库:数据存放在磁盘，通过mmap调用，将数据映射到内存中，可以将mmap理解为加速方式，mmap调用可以使得对普通文件的操作像是在内存中进行读写一样，将文件映射到调用进程的地址空间中，实现文件所在的磁盘物理地址和进程空间的虚拟地址，映射关系

使用Redis进行缓存，可以解决高并发请款修改的数据读压力

SQL对数据进行清洗:
  1.检查完整性:
    删除数据缺失的记录
    使用当前列的均值
    使用当前列出现频率最高的数据
  2.检查全面性
    字段类型定义修改

数据集成: 将不同来源 不同规范以及不同质量的数据进行统一收集和整理，为后续数据分析提供统一的数据

OLTP: 注重数据的实时性
OLAP: 注重数据的分析性

将数据OLTP 转换为 OLAP 中间的转换过程就是ETL
  E: 抽取  Extract 全量抽取、增量抽取
  T: 转换  Transform 数据字段的映射，数据请求，数据验证，数据过滤
  L: 加载  Load
```

```
软件建模比较知名的4+1视图模型:
  逻辑视图: 描述软件的功能逻辑，由哪些模块组成，模块中包含哪些类 以及依赖关系如何
  开发视图: 包括系统架构层面的层次划分，包的管理，依赖的系统与第三方的程序包
  过程视图: 描述程序运行期的进程、线程、对象实例 以及与此相关的并发、同步、通信等问题
  物理视图: 描述
  场景视图

软件建模与设计过程拆分三部分
  需求分析 
  概要设计
  详细设计
UML规范:
  类图: 描述类的特性和类之间的静态关系  [类的名称、类的属性列表、类的方法列表]
    类与类之间有六种静态关系: 关系、依赖、组合、聚合、继承、范化 
  序列图
  组件图
  部署图
  用例图
  状态图
  活动图
```


Appendix
--------
```
First Principle: 第一原理, 哲学与逻辑名词，是一个最基本的命题或假设，不能被省略或删除，也不能被违反.
```
