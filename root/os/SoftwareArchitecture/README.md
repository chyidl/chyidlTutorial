Software Architecture
=====================
```
物理服务器: [CPU 内存 磁盘 网卡]
  操作系统: [进程管理、硬件资源管理]
    JVM进程: [进程内虚拟机管理]
      TOMCAT容器: [每个用户请求分配一个线程，执行应用程序代码]
        应用程序: [可执行字节码war包]

多线程访问共享资源的代码被称为临界区,线程安全问题主要方法是使用锁，将临界区的代码加锁,只有获得锁才能执行临界区代码. 锁会引起线程阻塞,
被阻塞的线程越多，占据的系统资源越多，被阻塞线程不能继续执行，也不能释放当前占据的资源，在系统中一边等待一边消耗资源,如果阻塞的线程数超过某个系统资源的极限，会导致系统宕机，应用崩溃

解决系统因高并发而导致的响应变慢，应用崩溃主要手段是使用分布式系统架构。或在请求入口进行限流，减少系统的并发请求数
```

```
数组: 内存连续空间，存放相同的数据类型; 随机快速读写;
链表: 不连续存储，
Hash表: Key,Value 方式存储；Hash表的物理存储其实是数组, 根据Key计算出数组下标, Hashcode: 余数法; Hash冲突解决方法是链表法
栈: 后进先出 -- 在线性表基础上增加操作权限，因为栈不需要随机访问，也不需要在中间添加、删除数据可以使用数组实现或链表实现
队列: 先进先出 
  数组+链表+栈+队列称为线性表: 每个数据元素的前面只能有一个前驱数据元素，后面也只能有一个后继数据元素.
树: 非线性表
```

```
JVM: Java Virtual Machine 
  1. 类加载器
  2. 运行时数据区 [方法区 + 堆 + Java 栈 + 程序计数寄存器]
  3. 执行引擎 : 执行引擎执行字节码指令是解释执行,JVM进行优化，将频繁执行的代码编译为底层CPU指令存储起来(JIT) -server 参数打开JIT C2编译器进行优化

JVM 使用一种可达性分析算法：引用标记算法 
  JVM 对垃圾对象占内存进行回收三种方法:
    1. 清理: 垃圾对象占用的内存空间标记为空闲
    2. 压缩: 从堆空间的头部开始，将存活的对象拷贝放在一段连续的内存空间中，其余空间就是连续的空间空间
    3. 复制: 将堆空间分成两部分:其中一部分创建对象,当这个部分空间用完的时候，将标记的可用对象复制到另一个空间中,JVM 将两个空间分别命名为from区域和to区域

  JVM 具体进行垃圾回收时候，进行分代回收，JVM将堆空间分成新生代Young,老年代old两个区域,新生代分为Eden区，From区，To区三个区域:每次垃圾回收都是扫描Eden区和From区，将存活对象复制到To区，然后交换From区和To区的名称引用，下次垃圾回收的时候继续将存活对象从From 区复制到To区，当一个对象讲过几次新生代垃圾回收，也就是几次从From区复制到To区以后，依然存活，那么这个对象就会被复制到老年代区域.

当老年代空间满，将会堆新生代和老年代的内存空间进行一次全量垃圾回收，Full GC.

垃圾回收器:
  1. Serial串行垃圾回收器: 只有一个线程执行垃圾回收
  2. Parallel并行垃圾回收器: 启动多线程垃圾回收
  当垃圾回收线程工作的时候，必须要停止用户线程的工作 -- 垃圾回收称为"stop the world" 
  3. CMS 并发垃圾回收器: 垃圾回收的某些阶段，垃圾回收线程和用户线程可以并发运行 
  4. G1垃圾回收器: 将对空间分成多个子区域，然后在子区域上独立进行垃圾回收，

OutOfMemoryError: 堆空间不足 调整-Xmx参数增加内存空间 可以使用jmap命令查堆中对象情况分析是否存在内存泄漏
StackOverflowError: 栈帧太多，查看栈异常信息观察是否存在错误的递归调用 调整-Xss 参数增加栈空间
运行卡顿,部分请求响应延迟，可以通过jstat命令查看垃圾回收器 是否出现较长时间的FullGC 调整垃圾回收器相关参数

内存溢出 VS 内存泄漏
  内存溢出: 申请内存超过JVM当前可以分配的最大内存，溢出
  内存泄漏: 期望被回收的内存对象没有被回收，泄漏
```

Appendix
--------
```
First Principle: 第一原理, 哲学与逻辑名词，是一个最基本的命题或假设，不能被省略或删除，也不能被违反.
```
