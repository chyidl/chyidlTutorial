Data Structures and Algorithms
==============================
> 人生路上、我们回遇到很多坎坷，跨过去，你就可以成长，跨不过去就是困难和停滞。而且后面很长的一段时间里，你都需要为这个困难买单。

复杂度分析
--------
```

```

Array
-----
* Implementation an array that supports dynamic expansion 
- [Python3 Implement : array_dynamic_append_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/array_dynamic_append_implement.py)
* Implementation an ordered array of fixed size, support dynamic additions and deletions 
- [Python3 Implement: array_fixed_size_CURD_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/array_fixed_size_CURD_implement.py)
* Implementation two ordered arrays into one ordered array. 
- [Python3 array_merge_sorted_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/array_merge_sorted_implement.py)

Linked List
-----------
* Implement single-linked list, circular linked list, and doubly linked list to support addition and deletion operations 
- [Python3 Implement : linked_list_singly_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/linked_list_singly_implement.py)
- [Python3 Implement : linked_list_singly_circular_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/linked_list_singly_circular_implement.py)
- [Python3 linked_list_doubly_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/linked_list_doubly_implement.py)
* Implement single-linked list reversed
- [Python3 Implement : linked_list_singly_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/linked_list_singly_implement.py)
* Implementing two ordered linked lists into one ordered list 
- [Python3 Implement : linked_list_merge_two_sorted_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/linked_list_merge_two_sorted_implement.py)
* Implement the intermediate node of the linked list 


Stack
-----
* Implement a sequential stack with arrays 
- [Python3 stack_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/stack_array_implement.py)
* Implement a chain stack with a linked list 
- [Python3 stack_linked_list_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/stack_linked_list_implement.py)
* Programming simulation to implement a browser's forward and backward functions
- [stack_browser_back_forward_button_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/stack_browser_back_forward_button_implement.py)


Heap
----
* Implement a small top heap, a large top heap, and a priority queue 
* Implement heap sorting 
* Merging K ordered arrays with priority queues 
* Find the largest Top K of a set of dynamic data sets

Queue
-----
* Implement an order queue with arrays 
- [Python3 queue_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/queue_array_implement.py)
* Implement a chained queue with a linked list 
- [Python3 queue_linked_list_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/queue_linked_list_implement.py)
* Implement a circular queue 
- [Python3 queue_circular_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/queue_circular_array_implement.py)

Binary Tree
-----------
* Implement a binary search tree and support insert, delete, and find operations 
* Implement the lookup of the successor and precursor nodes of a node in the binary search tree 
* Implement binary, pre-, post-, and post-order traversal 

Graph
-----
* Implementing directed graph, undirected graph, entitlement graph, and unweight graph representation method Asymmetric matrix and adjacency list. 
* Depth-first search, breadth-first search for graphs 
* Implement Bellman-Ford algorithm, A algorithm.
- [Python3 Bellman-Ford_algorithm_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/Bellman-Ford_algorithm_implement.py)
* Implement Dijkstra algorithm, A algorithm 
* Kahn algorithm and DFS algroithm for toplogical sorting 

Recursive
---------
* Programming to achieve Fibonacci sequence evaluation 
- [Python3 recursion_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/recursion_implement.py)
* Programming to achieve factorial 
- [Python3 recursion_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/recursion_implement.py)
* Programming implements a full array of data sets 
- [Python3 recursion_arrangement_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/recursion_arrangement_implement.py)

Sort
----
* Implement merge sort, quick sort, insert sort, bubble sort, select sort
- [Python3 sort_bubble_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/sort_bubble_array_implement.py)
- [Python3 sort_insert_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/sort_insert_array_implement.py)
- [Python3 sort_selection_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/sort_selection_array_implement.py)
- [Python3 sort_merge_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/sort_merge_array_implement.py)
- [Python3 sort_quick_array_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/sort_quick_array_implement.py)
* Programming to achieve the Kth element of a set of data within O(n) time complexity

Binary search 
-------------
* Implement a binary search algorithm with ordered array 
* Implement fuzzy binary search algorithm (Such as the first element greater than or euqal to the given value)

Hash list
---------
* Implement a list of calculations based on linked list method to solve conflict problems
* LRU(Least Recently Used) Cache Implementation
- [Python3 linked_list_LRU_implement.py](/root/os/DSAA/DataStructuresAndAlgorithms/python/linked_list_LRU_implement.py)


String 
------
* Implement a character set that contains only the 26-character Trie tree of a~z 
* Implement a simple string matching algorithm 

Backtracking
---------------
* Using backtracking algorithm to solve the problem of eight queens 
* Using backtracking algorithm to solve 0-1 knapsack problem 

Division and treatment algorithm
-------------------------------------
* Using the divide and conquer algorithm to find the reverse order of a set of data 

Dynamic planning 
--------------------
* 0-1 backpack problem 
* Sum of Minimum path 
* Programming to achieve the shortest edit distance of Levins 
* Programmatically find the longest common subsequence of two strings 
* Programming to implement the longest increasing subsequence of a data sequence

Chyidl Utils -- chutils
-----------------------
A series of convenience functions to make programming easier with python3
<<<<<<< HEAD
- [chutils](/root/os/DSAA/DataStructuresAndAlgorithms/python/chutils)
||||||| d5d8e56
- [chutils](/root/os/DSAA/DataStructuresAndAlgorithms/python/chutils)
=======
- [chutils](/root/os/DSAA/DataStructuresAndAlgorithms/python/chutils)

Scheduling Algorithm
--------------------

* Bloom Filter - 布隆过滤器
> 布隆过滤器是1970年由布隆提出，它实际上是一个很长的二进制向量和一系列随机映射函数.布隆过滤器可以用于检索一个元素是否在一个集合中。优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难.
```
判断一个元素是不是在一个集合中，一般思路是将集合中所有元素保存起来，然后比较确定
    链表结构: 时间复杂度O(n)
    树结构: 时间复杂度O(log n)
    散列表结构: 时间复杂度O(1)

布隆过滤器的原理是当一个元素被加入集合中，通过K个散列函数将这个元素映射成一个数组中的K个点，把他们置为1.检索时，只要查看这些点是不是都是1就(大约)知道集合中有没有它，如果这些点有任何一个0，则被检元素一定不在。如果都是1，怎被检元素很可能在.

优点:
    相比其他数据结构，布隆过滤器在空间和时间方面都有巨大的优势，布隆过滤器存储空间和插入/查询时间都是常数(O(K)). 另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势.
    布隆过滤器可以表示全集，其他任何数据结构都不能
    k和m相同,使用同一组散列函数的两个布隆过滤器的交并运算可以使用位操作进行.

缺点:
    但是布隆过滤器的缺点和优点一样明显，误算率是其中之一，随着存入的元素数量的增加，误算率随之增加，但是如果元素数量太少，则使用散列表足以
    一般情况下不能从布隆过滤器中删除元素，很容易想到把位数组变成整数数组,每插入一个元素响应的计算器加一，这样删除元素时将计数器减掉就可以，然而要保证安全地删除元素并非如此简单，首先我们必须保证删除的元素的确在布隆过滤器里面，这一点单凭这个过滤器时无法保证的，另外计数器回绕也会造成问题
```

* Round-robin scheduling 
```
Round-robin (RR) is one of the algorithms employed by process and network schedulers in computing. Round-robin scheduling is simple, easy to implement, and starvation-free.Round-robin scheduling can also be applied to other scheduling problems, such as data packet scheduling in computer networks. It is an operating system concept.

Round Robin is a CPU scheduling algorithm where each process is assigned a fixed time slot in a cyclic way. 

    1. It is simple, easy to implement, and starvation-free as all processes get fair share of CPU. 
    2. One of the most commonly used technique in CPU scheduling as a core. 
    3. It is preemptive as processes are assigned CPU only for a fixed slice of time at most.
    4. The disadvantage of it is more overhead of context switching.

AWT(average waiting time): 
```
>>>>>>> 17e65b27933a988ecb5aa15f7047add37944e12c
